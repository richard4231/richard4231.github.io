<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herleitung Kugelvolumen</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
        }
        body {
            font-family: 'Roboto', Arial, sans-serif;
            overflow: hidden;
            background: #333;
            border: 10px solid #e0e0e0;
            border-radius: 12px;
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        canvas {
            display: block;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            margin: 10px;
            touch-action: none;
        }
        #pageTitle {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 50;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            min-width: 260px;
            border: 2px solid #666;
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 100;
        }
        #controls.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        #togglePanel {
            position: absolute;
            top: 15px;
            left: 285px; /* Adjusted to match panel width + margin */
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #666;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
            transition: left 0.3s ease;
        }
        #togglePanel:hover {
            background: rgba(50, 50, 50, 0.9);
        }
        #togglePanel.panel-closed {
            left: 15px;
        }
        #togglePanel .hamburger {
            display: none;
        }
        #togglePanel .close {
            display: inline;
        }
        #togglePanel.panel-closed .hamburger {
            display: inline;
        }
        #togglePanel.panel-closed .close {
            display: none;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 5px;
        }
        .color-button {
            width: 40px;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-button:hover {
            transform: scale(1.1);
        }
        .color-button.active {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        button {
            padding: 8px 15px;
            background: #4a4a4a;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #5a5a5a;
        }
        button.active {
            background: #2a7fff;
            border-color: #2a7fff;
        }
        .instructions {
            font-size: 11px;
            color: #aaa;
            margin-top: 15px;
            line-height: 1.4;
        }
        #pickInfo {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 15px;
            border-radius: 5px;
            font-size: 13px;
            display: none;
            pointer-events: none;
            max-width: 280px;
            border: 1px solid #555;
        }
        #pickInfo h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        #pickInfo .row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }
        #pickInfo .label {
            color: #aaa;
        }
        #pickInfo .value {
            font-weight: bold;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <h1 id="pageTitle">Herleitung Kugelvolumen</h1>
    <div id="pickInfo"></div>
    <button id="togglePanel" class="panel-closed"><span class="hamburger">&#9776;</span><span class="close">&#10005;</span></button>
    <div id="controls" class="hidden">
        <h3 style="margin: 0 0 15px 0; padding-bottom: 10px; border-bottom: 1px solid #555;">Steuerung</h3>
        <div class="control-group">
            <label>Anzahl Scheiben: <span class="value-display" id="stepsValue">10</span></label>
            <input type="range" id="stepsSlider" min="3" max="100" value="10" step="1">
        </div>

        <div class="control-group">
            <label>Abstand: <span class="value-display" id="heightValue">0</span></label>
            <input type="range" id="heightSlider" min="0" max="60" value="0" step="1">
        </div>

        <div class="control-group">
            <label>Polygon-Genauigkeit: <span class="value-display" id="segmentsValue">96</span></label>
            <input type="range" id="segmentsSlider" min="12" max="180" value="96" step="6">
        </div>

        <div class="control-group">
            <label>Helligkeit: <span class="value-display" id="brightnessValue">100%</span></label>
            <input type="range" id="brightnessSlider" min="20" max="200" value="100" step="5">
        </div>

        <div class="control-group">
            <label>Farbschema:</label>
            <div class="color-grid" id="colorGrid"></div>
        </div>

        <div class="control-group" style="display: flex; gap: 10px;">
            <button id="cameraFlyBtn">Kameraflug</button>
            <button id="resetBtn">Zurücksetzen</button>
        </div>
        
        <div class="instructions">
            <strong>Steuerung:</strong><br>
            • Klick/Tap: Flächeninhalt anzeigen (ungenau)<br>
            • Ziehen/Touch: Objekt rotieren<br>
            • Mausrad/Pinch: Zoomen<br>
            • W/A/S/D: Kamera bewegen<br>
            • Pfeiltasten: Kamera hoch/runter
        </div>
    </div>

    <script type="module">
        import { mat4, vec3 } from 'https://wgpu-matrix.org/dist/2.x/wgpu-matrix.module.js';

        // Farbschemata
        const colorSchemes = [
            { name: 'Ocean', mode: 'segment', from: [135, 206, 250], to: [25, 25, 112] },
            { name: 'Fire', mode: 'position', from: [255, 240, 120], to: [255, 140, 20] },
            { name: 'Position', mode: 'position', from: [255, 100, 100], to: [100, 100, 255] },
            { name: 'Faces', mode: 'faces',
              colors: [
                [255, 200, 100], // Top
                [100, 200, 255], // Bottom
                [100, 255, 150], // Outer
                [255, 150, 200]  // Inner
              ]
            }
        ];

        let currentColorScheme = 0;

        // Volumen- und Flächenberechnung (normalisiert auf Radius = 1)
        function calculateVolumesAndAreas(nsteps, nSegments = 96) {
            const R = 1; // Normalisierter Radius
            const h1 = R / nsteps; // Höhe jeder Scheibe

            // Polygon-Korrekturfaktor: (n/2) * sin(2π/n) vs π
            // Ein n-Eck hat Fläche (n/2) * r² * sin(2π/n) statt π * r²
            const polygonFactor = (nSegments / 2) * Math.sin(2 * Math.PI / nSegments) / Math.PI;

            const results = {
                hemisphere: [],
                tori: [],
                totalHemisphere: 0,
                totalTori: 0,
                totalHemispherePolygon: 0,
                totalToriPolygon: 0,
                polygonFactor: polygonFactor,
                segments: nSegments
            };

            for (let j = 0; j < nsteps; j++) {
                // Halbkugel (Zylinder/Scheiben)
                const h = j * h1;
                const r_disc = Math.sqrt(R * R - h * h);
                // Ideale Werte (Kreis)
                const volume_disc = Math.PI * r_disc * r_disc * h1;
                const area_disc = Math.PI * r_disc * r_disc;
                // Polygon-Werte (n-Eck)
                const area_disc_polygon = area_disc * polygonFactor;
                const volume_disc_polygon = volume_disc * polygonFactor;

                results.hemisphere.push({
                    step: j,
                    height: h,
                    radius: r_disc,
                    volume: volume_disc,
                    volumePolygon: volume_disc_polygon,
                    baseArea: area_disc,
                    baseAreaPolygon: area_disc_polygon
                });
                results.totalHemisphere += volume_disc;
                results.totalHemispherePolygon += volume_disc_polygon;

                // Tori (Ringe)
                const r_outer = R;
                const r_inner = h;
                // Ideale Werte (Kreisring)
                const volume_ring = Math.PI * (r_outer * r_outer - r_inner * r_inner) * h1;
                const area_ring = Math.PI * (r_outer * r_outer - r_inner * r_inner);
                // Polygon-Werte (n-Eck-Ring)
                const area_ring_polygon = area_ring * polygonFactor;
                const volume_ring_polygon = volume_ring * polygonFactor;

                results.tori.push({
                    step: j,
                    height: h,
                    outerRadius: r_outer,
                    innerRadius: r_inner,
                    volume: volume_ring,
                    volumePolygon: volume_ring_polygon,
                    baseArea: area_ring,
                    baseAreaPolygon: area_ring_polygon
                });
                results.totalTori += volume_ring;
                results.totalToriPolygon += volume_ring_polygon;
            }

            // Theoretisches Volumen einer Halbkugel: (2/3) * π * R³
            results.theoreticalVolume = (2/3) * Math.PI * R * R * R;

            return results;
        }

        // Berechnung speichern und in Konsole ausgeben
        let volumeData = calculateVolumesAndAreas(10, 96);
        console.log('=== Cavalieri-Prinzip: Volumen- und Flächenberechnung ===');
        console.log('Normalisierter Radius r = 1');
        console.log('');
        console.log('Scheibe | Halbkugel-Fläche | Ring-Fläche | Differenz');
        console.log('--------|------------------|--------------|----------');
        for (let j = 0; j < volumeData.hemisphere.length; j++) {
            const hArea = volumeData.hemisphere[j].baseArea.toFixed(6);
            const tArea = volumeData.tori[j].baseArea.toFixed(6);
            const diff = Math.abs(volumeData.hemisphere[j].baseArea - volumeData.tori[j].baseArea).toFixed(10);
            console.log(`   ${j.toString().padStart(2)}   |     ${hArea}     |   ${tArea}   |  ${diff}`);
        }
        console.log('');
        console.log('Gesamtvolumen Halbkugel (ideal):', volumeData.totalHemisphere.toFixed(6));
        console.log('Gesamtvolumen Tori (ideal):', volumeData.totalTori.toFixed(6));
        console.log('Theoretisches Volumen (2/3)πR³:', volumeData.theoreticalVolume.toFixed(6));
        console.log('');
        console.log(`Polygon-Faktor (${volumeData.segments}-Eck):`, volumeData.polygonFactor.toFixed(6));
        console.log('Abweichung vom Idealwert:', ((1 - volumeData.polygonFactor) * 100).toFixed(3) + '%');
        console.log('Polygon-Volumen Halbkugel:', volumeData.totalHemispherePolygon.toFixed(6));
        console.log('Polygon-Volumen Tori:', volumeData.totalToriPolygon.toFixed(6));

        // WebGPU Setup
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('webgpu');
        
        if (!navigator.gpu) {
            alert('WebGPU wird von diesem Browser nicht unterstützt!');
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        
        context.configure({
            device,
            format: presentationFormat,
            alphaMode: 'premultiplied',
        });

        // Shader Code with multiple light sources
        const shaderCode = `
            struct Uniforms {
                viewProjection: mat4x4f,
                cameraPosition: vec3f,
                brightness: f32,
                light1: vec3f,
                _pad1: f32,
                light2: vec3f,
                _pad2: f32,
                light3: vec3f,
                _pad3: f32,
            }

            struct VertexOutput {
                @builtin(position) position: vec4f,
                @location(0) color: vec4f,
                @location(1) normal: vec3f,
                @location(2) worldPos: vec3f,
                @location(3) objectId: f32,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            @vertex fn vs(
                @location(0) position: vec3f,
                @location(1) color: vec4f,
                @location(2) normal: vec3f,
                @location(3) objectId: f32
            ) -> VertexOutput {
                var output: VertexOutput;
                output.position = uniforms.viewProjection * vec4f(position, 1.0);
                output.color = color;
                output.normal = normal;
                output.worldPos = position;
                output.objectId = objectId;
                return output;
            }

            fn calculateLight(normal: vec3f, lightDir: vec3f, viewDir: vec3f) -> f32 {
                // Diffuse
                let diffuse = max(dot(normal, lightDir), 0.0) * 0.5;

                // Specular
                let halfDir = normalize(lightDir + viewDir);
                let specular = pow(max(dot(normal, halfDir), 0.0), 32.0) * 0.2;

                return diffuse + specular;
            }

            @fragment fn fs(input: VertexOutput) -> @location(0) vec4f {
                let normal = normalize(input.normal);
                let viewDir = normalize(uniforms.cameraPosition - input.worldPos);

                // Ambient base
                let ambient = 0.2;

                // Calculate lighting from 3 sources
                let light1Dir = normalize(uniforms.light1);
                let light2Dir = normalize(uniforms.light2);
                let light3Dir = normalize(uniforms.light3);

                var lighting = ambient;
                lighting += calculateLight(normal, light1Dir, viewDir);
                lighting += calculateLight(normal, light2Dir, viewDir);
                lighting += calculateLight(normal, light3Dir, viewDir);

                // Apply brightness
                lighting *= uniforms.brightness;

                return vec4f(input.color.rgb * lighting, input.color.a);
            }
        `;

        const shaderModule = device.createShaderModule({
            label: 'Ring Shader',
            code: shaderCode,
        });

        // Picking shader - encodes objectId as RGB color for readback
        const pickingShaderCode = `
            struct Uniforms {
                viewProjection: mat4x4f,
                cameraPosition: vec3f,
                brightness: f32,
                light1: vec3f,
                _pad1: f32,
                light2: vec3f,
                _pad2: f32,
                light3: vec3f,
                _pad3: f32,
            }

            struct VertexOutput {
                @builtin(position) position: vec4f,
                @location(0) objectId: f32,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            @vertex fn vs(
                @location(0) position: vec3f,
                @location(1) color: vec4f,
                @location(2) normal: vec3f,
                @location(3) objectId: f32
            ) -> VertexOutput {
                var output: VertexOutput;
                output.position = uniforms.viewProjection * vec4f(position, 1.0);
                output.objectId = objectId;
                return output;
            }

            @fragment fn fs(input: VertexOutput) -> @location(0) vec4f {
                // Encode objectId as RGB (can handle up to 256^3 = 16M objects)
                let id = u32(input.objectId);
                let r = f32((id >> 16u) & 0xFFu) / 255.0;
                let g = f32((id >> 8u) & 0xFFu) / 255.0;
                let b = f32(id & 0xFFu) / 255.0;
                return vec4f(r, g, b, 1.0);
            }
        `;

        const pickingShaderModule = device.createShaderModule({
            label: 'Picking Shader',
            code: pickingShaderCode,
        });

        // Pipeline
        const vertexState = {
            module: shaderModule,
            entryPoint: 'vs',
            buffers: [
                {
                    arrayStride: 11 * 4, // position(3) + color(4) + normal(3) + objectId(1)
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' },  // position
                        { shaderLocation: 1, offset: 12, format: 'float32x4' }, // color
                        { shaderLocation: 2, offset: 28, format: 'float32x3' }, // normal
                        { shaderLocation: 3, offset: 40, format: 'float32' },   // objectId
                    ],
                },
            ],
        };

        const pipeline = device.createRenderPipeline({
            label: 'Ring Pipeline',
            layout: 'auto',
            vertex: vertexState,
            fragment: {
                module: shaderModule,
                entryPoint: 'fs',
                targets: [{ format: presentationFormat }],
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'none',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        // Picking Pipeline
        const pickingPipeline = device.createRenderPipeline({
            label: 'Picking Pipeline',
            layout: 'auto',
            vertex: {
                module: pickingShaderModule,
                entryPoint: 'vs',
                buffers: [
                    {
                        arrayStride: 11 * 4,
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: 'float32x3' },
                            { shaderLocation: 1, offset: 12, format: 'float32x4' },
                            { shaderLocation: 2, offset: 28, format: 'float32x3' },
                            { shaderLocation: 3, offset: 40, format: 'float32' },
                        ],
                    },
                ],
            },
            fragment: {
                module: pickingShaderModule,
                entryPoint: 'fs',
                targets: [{ format: 'rgba8unorm' }],
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'none',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        // Geometrie-Generierung
        function lerpColor(from, to, t) {
            return [
                from[0] + (to[0] - from[0]) * t,
                from[1] + (to[1] - from[1]) * t,
                from[2] + (to[2] - from[2]) * t,
                255
            ];
        }

        function generateRingGeometry(radius, height, innerRadius, offset, steps, colorScheme, objectIdBase, ringIndex, totalRings) {
            const vertices = [];
            const angle = 2 * Math.PI / steps;

            for (let i = 0; i < steps; i++) {
                const u = i * angle;
                const u1 = (i + 1) * angle;

                // Color based on mode
                let colorNorm;
                if (colorScheme.mode === 'segment') {
                    const color = lerpColor(colorScheme.from, colorScheme.to, i / steps);
                    colorNorm = [color[0]/255, color[1]/255, color[2]/255, 1.0];
                } else if (colorScheme.mode === 'position') {
                    const color = lerpColor(colorScheme.from, colorScheme.to, ringIndex / totalRings);
                    colorNorm = [color[0]/255, color[1]/255, color[2]/255, 1.0];
                } else if (colorScheme.mode === 'uniform') {
                    colorNorm = [colorScheme.color[0]/255, colorScheme.color[1]/255, colorScheme.color[2]/255, 1.0];
                }

                // Outer ring vertices
                const x0 = Math.sin(u) * radius;
                const z0 = Math.cos(u) * radius;
                const x1 = Math.sin(u1) * radius;
                const z1 = Math.cos(u1) * radius;

                // Inner ring vertices
                const x2 = Math.sin(u1) * innerRadius;
                const z2 = Math.cos(u1) * innerRadius;
                const x3 = Math.sin(u) * innerRadius;
                const z3 = Math.cos(u) * innerRadius;

                const y0 = offset;
                const y1 = offset + height;

                const objectId = objectIdBase + i;

                // For 'faces' mode, calculate colors per face
                if (colorScheme.mode === 'faces') {
                    const topColor = [colorScheme.colors[0][0]/255, colorScheme.colors[0][1]/255, colorScheme.colors[0][2]/255, 1.0];
                    const bottomColor = [colorScheme.colors[1][0]/255, colorScheme.colors[1][1]/255, colorScheme.colors[1][2]/255, 1.0];
                    const outerColor = [colorScheme.colors[2][0]/255, colorScheme.colors[2][1]/255, colorScheme.colors[2][2]/255, 1.0];
                    const innerColor = [colorScheme.colors[3][0]/255, colorScheme.colors[3][1]/255, colorScheme.colors[3][2]/255, 1.0];

                    // Bottom face
                    addQuad(vertices,
                        [x0, y0, z0], [x1, y0, z1], [x2, y0, z2], [x3, y0, z3],
                        [0, -1, 0], bottomColor, objectId);

                    // Outer side face
                    const outerNormal = vec3.normalize([x0, 0, z0]);
                    addQuad(vertices,
                        [x0, y0, z0], [x0, y1, z0], [x1, y1, z1], [x1, y0, z1],
                        outerNormal, outerColor, objectId);

                    // Top face
                    addQuad(vertices,
                        [x0, y1, z0], [x1, y1, z1], [x2, y1, z2], [x3, y1, z3],
                        [0, 1, 0], topColor, objectId);

                    // Inner side face
                    const innerNormal = vec3.normalize([-x3, 0, -z3]);
                    addQuad(vertices,
                        [x3, y0, z3], [x2, y0, z2], [x2, y1, z2], [x3, y1, z3],
                        innerNormal, innerColor, objectId);
                } else {
                    // Bottom face (outer to inner) - normal points down
                    addQuad(vertices,
                        [x0, y0, z0], [x1, y0, z1], [x2, y0, z2], [x3, y0, z3],
                        [0, -1, 0], colorNorm, objectId);

                    // Outer side face - normal points outward
                    const outerNormal = vec3.normalize([x0, 0, z0]);
                    addQuad(vertices,
                        [x0, y0, z0], [x0, y1, z0], [x1, y1, z1], [x1, y0, z1],
                        outerNormal, colorNorm, objectId);

                    // Top face - normal points up
                    addQuad(vertices,
                        [x0, y1, z0], [x1, y1, z1], [x2, y1, z2], [x3, y1, z3],
                        [0, 1, 0], colorNorm, objectId);

                    // Inner side face - normal points inward
                    const innerNormal = vec3.normalize([-x3, 0, -z3]);
                    addQuad(vertices,
                        [x3, y0, z3], [x2, y0, z2], [x2, y1, z2], [x3, y1, z3],
                        innerNormal, colorNorm, objectId);
                }
            }

            return vertices;
        }

        function addQuad(vertices, p0, p1, p2, p3, normal, color, objectId) {
            // Triangle 1: p0, p1, p2
            vertices.push(...p0, ...color, ...normal, objectId);
            vertices.push(...p1, ...color, ...normal, objectId);
            vertices.push(...p2, ...color, ...normal, objectId);

            // Triangle 2: p0, p2, p3
            vertices.push(...p0, ...color, ...normal, objectId);
            vertices.push(...p2, ...color, ...normal, objectId);
            vertices.push(...p3, ...color, ...normal, objectId);
        }

        // Generate a box/table geometry
        function generateBoxGeometry(x, y, z, width, height, depth, color, objectId) {
            const vertices = [];
            const colorNorm = [color[0]/255, color[1]/255, color[2]/255, 1.0];

            const hw = width / 2;
            const hd = depth / 2;

            // 8 corners of the box
            const corners = [
                [x - hw, y, z - hd],           // 0: bottom-left-front
                [x + hw, y, z - hd],           // 1: bottom-right-front
                [x + hw, y, z + hd],           // 2: bottom-right-back
                [x - hw, y, z + hd],           // 3: bottom-left-back
                [x - hw, y + height, z - hd],  // 4: top-left-front
                [x + hw, y + height, z - hd],  // 5: top-right-front
                [x + hw, y + height, z + hd],  // 6: top-right-back
                [x - hw, y + height, z + hd],  // 7: top-left-back
            ];

            // Top face
            addQuad(vertices, corners[4], corners[5], corners[6], corners[7], [0, 1, 0], colorNorm, objectId);
            // Bottom face
            addQuad(vertices, corners[0], corners[3], corners[2], corners[1], [0, -1, 0], colorNorm, objectId);
            // Front face
            addQuad(vertices, corners[0], corners[1], corners[5], corners[4], [0, 0, -1], colorNorm, objectId);
            // Back face
            addQuad(vertices, corners[2], corners[3], corners[7], corners[6], [0, 0, 1], colorNorm, objectId);
            // Left face
            addQuad(vertices, corners[3], corners[0], corners[4], corners[7], [-1, 0, 0], colorNorm, objectId);
            // Right face
            addQuad(vertices, corners[1], corners[2], corners[6], corners[5], [1, 0, 0], colorNorm, objectId);

            return vertices;
        }

        function generateAllGeometry(heightOffset, colorScheme, nsteps = 10, segments = 96) {
            const radius = 200;
            const hslice = radius / nsteps;
            const allVertices = [];
            let objectIdCounter = 0;

            // Semisphere (shifted left to center rotation) - pointing UP
            const centerOffset = radius * 1.5;
            for (let j = 0; j < nsteps; j++) {
                const h2 = hslice * j;
                const r1 = Math.sqrt(radius * radius - h2 * h2);
                const r2 = 0;
                const h1 = radius / nsteps;
                const voffset = (h1 + heightOffset) * j;
                const ringVerts = generateRingGeometry(r1, h1, r2, voffset, segments, colorScheme, objectIdCounter, j, nsteps);

                // Shift left to center
                for (let k = 0; k < ringVerts.length; k += 11) {
                    ringVerts[k] -= centerOffset;
                }

                allVertices.push(...ringVerts);
                objectIdCounter += segments;
            }

            // Tori (shifted right to center rotation) - stacking UP
            for (let j = 0; j < nsteps; j++) {
                const h2 = hslice * j;
                const r2 = h2;
                const h1 = radius / nsteps;
                const voffset = (h1 + heightOffset) * j;
                const ringVerts = generateRingGeometry(radius, h1, r2, voffset, segments, colorScheme, objectIdCounter, j, nsteps);

                // Shift right to center
                for (let k = 0; k < ringVerts.length; k += 11) {
                    ringVerts[k] += centerOffset;
                }

                allVertices.push(...ringVerts);
                objectIdCounter += segments;
            }

            // Table (anthracite colored box below both objects)
            const anthracite = [50, 50, 55];
            const tableWidth = radius * 8;  // Wide enough to span both objects (doubled)
            const tableHeight = 40;          // Doubled
            const tableDepth = radius * 5;   // Doubled
            const tableY = -tableHeight - 10;  // Below the objects with small gap
            const tableVerts = generateBoxGeometry(0, tableY, 0, tableWidth, tableHeight, tableDepth, anthracite, objectIdCounter);
            allVertices.push(...tableVerts);

            return new Float32Array(allVertices);
        }

        // Initial geometry
        let geometryData = generateAllGeometry(0, colorSchemes[currentColorScheme]);
        let vertexBuffer = device.createBuffer({
            label: 'Vertex Buffer',
            size: geometryData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, geometryData);
        let numVertices = geometryData.length / 11;

        // Uniforms
        const uniformBufferSize =
            16 * 4 + // viewProjection matrix (64 bytes)
            4 * 4 +  // cameraPosition + brightness (16 bytes)
            4 * 4 +  // light1 + padding (16 bytes)
            4 * 4 +  // light2 + padding (16 bytes)
            4 * 4;   // light3 + padding (16 bytes)
        // Total: 128 bytes = 32 floats

        let currentBrightness = 1.0;

        const uniformBuffer = device.createBuffer({
            size: uniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
            ],
        });

        // Picking bind group (uses same uniform buffer)
        const pickingBindGroup = device.createBindGroup({
            layout: pickingPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
            ],
        });

        // Picking textures and buffers
        let pickingTexture = null;
        let pickingDepthTexture = null;
        let pickingTextureSize = { width: 0, height: 0 };

        function createPickingTextures(width, height) {
            if (pickingTexture) pickingTexture.destroy();
            if (pickingDepthTexture) pickingDepthTexture.destroy();

            pickingTexture = device.createTexture({
                size: [width, height],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            });

            pickingDepthTexture = device.createTexture({
                size: [width, height],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT,
            });

            pickingTextureSize = { width, height };
        }

        // Set canvas size with HiDPI/Retina support
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        console.log('Canvas size:', canvas.width, 'x', canvas.height, '(DPR:', dpr + ')');

        // Depth texture
        let depthTexture = null;

        function createDepthTexture(width, height) {
            if (depthTexture) {
                depthTexture.destroy();
            }
            depthTexture = device.createTexture({
                size: [width, height],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT,
            });
            console.log('Created depth texture:', width, 'x', height);
        }

        // Camera state
        const camera = {
            position: vec3.create(0, 700, 1200),
            target: vec3.create(0, 100, 50), // Center at origin
            up: vec3.create(0, 1, 0), // definiert Richtung für up/down
            fov: 60 * Math.PI / 180,
            near: 1,
            far: 5000,
        };

        console.log('Camera position:', camera.position);
        console.log('Camera target:', camera.target);
        console.log('Generated vertices:', numVertices);
        console.log('First few vertices:', geometryData.slice(0, 33));

        // Camera fly animation
        let cameraFlyActive = false;
        let flyTime = 0;
        const flyRadius = 1500;
        const flyHeight = 500;
        const flySpeed = 0.5;

        // Mouse interaction
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let rotation = { x: 0.15, y: -20 * Math.PI / 180 }; // Leicht nach vorne gekippt, 20° im Uhrzeigersinn

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                rotation.y += deltaX * 0.005;
                rotation.x += deltaY * 0.005;

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', (e) => {
            isDragging = false;
        });

        // Touch events for mobile support
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchStartDistance = 0;
        let initialZoom = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                const direction = vec3.subtract(camera.target, camera.position);
                initialZoom = vec3.length(direction);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - lastTouchX;
                const deltaY = e.touches[0].clientY - lastTouchY;
                rotation.y += deltaX * 0.005;
                rotation.x += deltaY * 0.005;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                hidePickInfo();
            } else if (e.touches.length === 2) {
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = touchStartDistance / distance;
                const direction = vec3.subtract(camera.target, camera.position);
                vec3.normalize(direction, direction);
                const newDistance = Math.max(100, Math.min(initialZoom * scale, 3000));
                camera.position = vec3.subtract(camera.target, vec3.scale(direction, newDistance));
                hidePickInfo();
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length === 0) {
                isDragging = false;
            } else if (e.touches.length === 1) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
        }, { passive: false });

        canvas.addEventListener('touchcancel', () => {
            isDragging = false;
        });

        // Pick info display
        const pickInfo = document.getElementById('pickInfo');
        let lastClickX = 0;
        let lastClickY = 0;
        let pickingInProgress = false;

        function hidePickInfo() {
            pickInfo.style.display = 'none';
        }

        function showPickInfo(x, y, ringIndex, isHemisphere, data) {
            const objectType = isHemisphere ? 'Scheibe' : 'Kreisring';
            const abweichung = ((1 - volumeData.polygonFactor) * 100).toFixed(3);

            let html = `<h4>${objectType} #${ringIndex + 1}</h4>`;
            html += `<div class="row"><span class="label">Höhe:</span><span class="value">${data.height.toFixed(3)}</span></div>`;

            if (isHemisphere) {
                html += `<div class="row"><span class="label">Radius r:</span><span class="value">${data.radius.toFixed(3)}</span></div>`;
            } else {
                html += `<div class="row"><span class="label">r aussen:</span><span class="value">${data.outerRadius.toFixed(3)}</span></div>`;
                html += `<div class="row"><span class="label">r innen:</span><span class="value">${data.innerRadius.toFixed(3)}</span></div>`;
            }

            html += `<div style="margin-top:8px; padding-top:6px; border-top:1px solid #444;">`;
            html += `<div style="font-size:11px; color:#888; margin-bottom:4px;">Ideal (Kreis):</div>`;
            html += `<div class="row"><span class="label">Grundfläche:</span><span class="value">${data.baseArea.toFixed(4)}</span></div>`;
            html += `<div class="row"><span class="label">Volumen:</span><span class="value">${data.volume.toFixed(4)}</span></div>`;
            html += `</div>`;

            html += `<div style="margin-top:8px; padding-top:6px; border-top:1px solid #444;">`;
            html += `<div style="font-size:11px; color:#888; margin-bottom:4px;">Polygon (${volumeData.segments}-Eck, -${abweichung}%):</div>`;
            html += `<div class="row"><span class="label">Grundfläche:</span><span class="value">${data.baseAreaPolygon.toFixed(4)}</span></div>`;
            html += `<div class="row"><span class="label">Volumen:</span><span class="value">${data.volumePolygon.toFixed(4)}</span></div>`;
            html += `</div>`;

            pickInfo.innerHTML = html;
            pickInfo.style.display = 'block';

            // Position near cursor but within viewport
            let posX = x + 15;
            let posY = y + 15;
            if (posX + 280 > window.innerWidth) posX = x - 295;
            if (posY + 250 > window.innerHeight) posY = y - 265;

            pickInfo.style.left = posX + 'px';
            pickInfo.style.top = posY + 'px';
        }

        async function performPicking(mouseX, mouseY) {
            if (pickingInProgress) return;
            pickingInProgress = true;

            try {
                const currentDpr = window.devicePixelRatio || 1;
                const width = canvas.width;
                const height = canvas.height;

                // Ensure picking textures exist and are correct size
                if (!pickingTexture || pickingTextureSize.width !== width || pickingTextureSize.height !== height) {
                    createPickingTextures(width, height);
                }

                // Calculate view-projection matrix (same as render loop)
                const aspect = width / height;
                const projection = mat4.perspective(camera.fov, aspect, camera.near, camera.far);

                let viewTarget = camera.target;
                let viewPosition = camera.position;
                if (cameraFlyActive) {
                    viewPosition = vec3.create(
                        Math.cos(flyTime) * flyRadius,
                        flyHeight + Math.sin(flyTime * 0.5) * 200,
                        Math.sin(flyTime) * flyRadius
                    );
                    viewTarget = vec3.create(0, 0, 0);
                }

                const view = mat4.lookAt(viewPosition, viewTarget, camera.up);
                const rotationMatrix = mat4.identity();
                mat4.rotateX(rotationMatrix, rotation.x, rotationMatrix);
                mat4.rotateY(rotationMatrix, rotation.y, rotationMatrix);
                const viewProjection = mat4.multiply(projection, mat4.multiply(view, rotationMatrix));

                // Update uniforms
                const uniformData = new Float32Array(32);
                uniformData.set(viewProjection, 0);
                uniformData.set([...viewPosition, currentBrightness], 16);
                uniformData.set([0.5, 1.0, 0.8, 0], 20);
                uniformData.set([-0.8, 0.3, 0.5, 0], 24);
                uniformData.set([0.2, -0.5, -0.6, 0], 28);
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                // Render picking pass
                const encoder = device.createCommandEncoder();
                const renderPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: pickingTexture.createView(),
                        clearValue: { r: 0, g: 0, b: 0, a: 0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: pickingDepthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store',
                    },
                });

                renderPass.setPipeline(pickingPipeline);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.setBindGroup(0, pickingBindGroup);
                renderPass.draw(numVertices);
                renderPass.end();

                // Copy a 5x5 pixel area for more reliable picking
                const sampleSize = 5;
                const halfSize = Math.floor(sampleSize / 2);
                const centerX = Math.floor(mouseX * currentDpr);
                const centerY = Math.floor(mouseY * currentDpr);

                // Clamp to canvas bounds
                const startX = Math.max(0, centerX - halfSize);
                const startY = Math.max(0, centerY - halfSize);
                const endX = Math.min(width - 1, centerX + halfSize);
                const endY = Math.min(height - 1, centerY + halfSize);
                const actualWidth = endX - startX + 1;
                const actualHeight = endY - startY + 1;

                // bytesPerRow must be aligned to 256
                const bytesPerRow = 256;
                const bufferSize = bytesPerRow * actualHeight;

                const stagingBuffer = device.createBuffer({
                    size: bufferSize,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                });

                encoder.copyTextureToBuffer(
                    { texture: pickingTexture, origin: { x: startX, y: startY } },
                    { buffer: stagingBuffer, bytesPerRow: bytesPerRow, rowsPerImage: actualHeight },
                    { width: actualWidth, height: actualHeight }
                );

                device.queue.submit([encoder.finish()]);

                // Read back pixels and count ring occurrences
                await stagingBuffer.mapAsync(GPUMapMode.READ);
                const data = new Uint8Array(stagingBuffer.getMappedRange());

                // Count occurrences of each ringIndex (not objectId, to group segments of same ring)
                const ringCounts = new Map();
                let totalValidPixels = 0;
                const totalRings = currentSteps * 2;

                for (let row = 0; row < actualHeight; row++) {
                    for (let col = 0; col < actualWidth; col++) {
                        const offset = row * bytesPerRow + col * 4;
                        const r = data[offset];
                        const g = data[offset + 1];
                        const b = data[offset + 2];
                        const a = data[offset + 3];

                        if (a === 0) continue; // Skip background

                        const objectId = (r << 16) | (g << 8) | b;
                        const ringIdx = Math.floor(objectId / currentSegments);

                        if (ringIdx >= totalRings) continue; // Skip table

                        totalValidPixels++;
                        ringCounts.set(ringIdx, (ringCounts.get(ringIdx) || 0) + 1);
                    }
                }

                stagingBuffer.unmap();
                stagingBuffer.destroy();

                // Find the most common ring (majority voting)
                if (totalValidPixels === 0) {
                    hidePickInfo();
                    pickingInProgress = false;
                    return;
                }

                let bestRingIndex = -1;
                let bestCount = 0;
                for (const [ringIdx, count] of ringCounts) {
                    if (count > bestCount) {
                        bestCount = count;
                        bestRingIndex = ringIdx;
                    }
                }

                const ringIndex = bestRingIndex;

                // Determine if hemisphere or torus and get corresponding data
                const isHemisphere = ringIndex < currentSteps;
                const actualRingIndex = isHemisphere ? ringIndex : ringIndex - currentSteps;

                if (isHemisphere && volumeData.hemisphere[actualRingIndex]) {
                    showPickInfo(mouseX, mouseY, actualRingIndex, true, volumeData.hemisphere[actualRingIndex]);
                } else if (!isHemisphere && volumeData.tori[actualRingIndex]) {
                    showPickInfo(mouseX, mouseY, actualRingIndex, false, volumeData.tori[actualRingIndex]);
                } else {
                    hidePickInfo();
                }
            } catch (err) {
                console.error('Picking error:', err);
            }

            pickingInProgress = false;
        }

        // Click handler for picking (only if not dragging)
        let mouseDownPos = { x: 0, y: 0 };
        canvas.addEventListener('mousedown', (e) => {
            mouseDownPos = { x: e.clientX, y: e.clientY };
        }, true);

        canvas.addEventListener('click', (e) => {
            // Only pick if mouse didn't move much (not a drag)
            const dx = e.clientX - mouseDownPos.x;
            const dy = e.clientY - mouseDownPos.y;
            if (Math.abs(dx) < 5 && Math.abs(dy) < 5) {
                performPicking(e.clientX, e.clientY);
            }
        });

        // Touch tap detection (separate from touchstart used for dragging)
        let touchStartPos = { x: 0, y: 0 };
        let touchStartTime = 0;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                touchStartTime = Date.now();
            }
        }, { passive: true, capture: true });

        canvas.addEventListener('touchend', (e) => {
            if (e.changedTouches.length === 1 && Date.now() - touchStartTime < 300) {
                const touch = e.changedTouches[0];
                const dx = touch.clientX - touchStartPos.x;
                const dy = touch.clientY - touchStartPos.y;
                if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                    performPicking(touch.clientX, touch.clientY);
                }
            }
        }, { passive: true, capture: true });

        // Hide pick info when starting to drag
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                hidePickInfo();
            }
        }, true);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            hidePickInfo(); // Hide pick info when zooming
            const zoomSpeed = 0.3; // Increased from 0.1
            const direction = vec3.subtract(camera.target, camera.position);
            const distance = vec3.length(direction);
            vec3.normalize(direction, direction);

            const zoomDelta = e.deltaY * zoomSpeed;
            const newDistance = Math.max(100, Math.min(distance + zoomDelta, 3000));

            camera.position = vec3.subtract(camera.target, vec3.scale(direction, newDistance));
        }, { passive: false });

        // Keyboard controls with acceleration
        const keys = {};
        let keyHoldTime = 0;
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true; // For arrow keys
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        function updateCameraFromKeys(deltaTime) {
            if (cameraFlyActive) return;

            // Check if any movement key is pressed
            const anyKeyPressed = keys['w'] || keys['s'] || keys['a'] || keys['d'] ||
                                  keys['ArrowUp'] || keys['ArrowDown'];

            if (anyKeyPressed) {
                keyHoldTime += deltaTime;
                hidePickInfo(); // Hide pick info when moving camera
            } else {
                keyHoldTime = 0;
            }

            // Speed doubles after 1 second of holding
            const speedMultiplier = keyHoldTime > 1.0 ? 2.0 : 1.0;
            const speed = 300 * deltaTime * speedMultiplier;

            const direction = vec3.normalize(vec3.subtract(camera.target, camera.position));
            const right = vec3.normalize(vec3.cross(direction, camera.up));

            if (keys['w']) {
                camera.position = vec3.add(camera.position, vec3.scale(direction, speed));
                camera.target = vec3.add(camera.target, vec3.scale(direction, speed));
            }
            if (keys['s']) {
                camera.position = vec3.subtract(camera.position, vec3.scale(direction, speed));
                camera.target = vec3.subtract(camera.target, vec3.scale(direction, speed));
            }
            if (keys['a']) {
                camera.position = vec3.subtract(camera.position, vec3.scale(right, speed));
                camera.target = vec3.subtract(camera.target, vec3.scale(right, speed));
            }
            if (keys['d']) {
                camera.position = vec3.add(camera.position, vec3.scale(right, speed));
                camera.target = vec3.add(camera.target, vec3.scale(right, speed));
            }
            // Arrow up/down for vertical movement
            if (keys['ArrowUp']) {
                camera.position = vec3.add(camera.position, vec3.scale(camera.up, speed));
                camera.target = vec3.add(camera.target, vec3.scale(camera.up, speed));
            }
            if (keys['ArrowDown']) {
                camera.position = vec3.subtract(camera.position, vec3.scale(camera.up, speed));
                camera.target = vec3.subtract(camera.target, vec3.scale(camera.up, speed));
            }
        }

        // Panel toggle
        const togglePanelBtn = document.getElementById('togglePanel');
        const controlsPanel = document.getElementById('controls');

        togglePanelBtn.addEventListener('click', () => {
            controlsPanel.classList.toggle('hidden');
            togglePanelBtn.classList.toggle('panel-closed');
        });

        // UI Controls
        const stepsSlider = document.getElementById('stepsSlider');
        const stepsValue = document.getElementById('stepsValue');
        const heightSlider = document.getElementById('heightSlider');
        const heightValue = document.getElementById('heightValue');
        const segmentsSlider = document.getElementById('segmentsSlider');
        const segmentsValue = document.getElementById('segmentsValue');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const brightnessValue = document.getElementById('brightnessValue');

        let currentSteps = 10;
        let currentSegments = 96;

        brightnessSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            brightnessValue.textContent = value + '%';
            currentBrightness = value / 100;
        });

        stepsSlider.addEventListener('input', (e) => {
            currentSteps = parseInt(e.target.value);
            stepsValue.textContent = currentSteps;
            const heightOffset = parseFloat(heightSlider.value);
            geometryData = generateAllGeometry(heightOffset, colorSchemes[currentColorScheme], currentSteps, currentSegments);

            // Recreate buffer if needed
            if (geometryData.byteLength > vertexBuffer.size) {
                vertexBuffer.destroy();
                vertexBuffer = device.createBuffer({
                    label: 'Vertex Buffer',
                    size: geometryData.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
            }

            device.queue.writeBuffer(vertexBuffer, 0, geometryData);
            numVertices = geometryData.length / 11;

            // Volumenberechnung aktualisieren
            volumeData = calculateVolumesAndAreas(currentSteps, currentSegments);
            console.log(`=== Aktualisiert für ${currentSteps} Scheiben, ${currentSegments} Segmente ===`);
            console.log('Gesamtvolumen Halbkugel:', volumeData.totalHemisphere.toFixed(6));
            console.log('Gesamtvolumen Tori:', volumeData.totalTori.toFixed(6));
            console.log('Theoretisches Volumen:', volumeData.theoreticalVolume.toFixed(6));
        });

        heightSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            heightValue.textContent = value.toFixed(0);
            geometryData = generateAllGeometry(value, colorSchemes[currentColorScheme], currentSteps, currentSegments);
            device.queue.writeBuffer(vertexBuffer, 0, geometryData);
            numVertices = geometryData.length / 11;
        });

        segmentsSlider.addEventListener('input', (e) => {
            currentSegments = parseInt(e.target.value);
            segmentsValue.textContent = currentSegments;
            const heightOffset = parseFloat(heightSlider.value);
            geometryData = generateAllGeometry(heightOffset, colorSchemes[currentColorScheme], currentSteps, currentSegments);

            // Recreate buffer if needed
            if (geometryData.byteLength > vertexBuffer.size) {
                vertexBuffer.destroy();
                vertexBuffer = device.createBuffer({
                    label: 'Vertex Buffer',
                    size: geometryData.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
            }

            device.queue.writeBuffer(vertexBuffer, 0, geometryData);
            numVertices = geometryData.length / 11;

            // Volumenberechnung aktualisieren (Polygon-Faktor ändert sich)
            volumeData = calculateVolumesAndAreas(currentSteps, currentSegments);
            console.log(`=== Polygon-Genauigkeit: ${currentSegments} Segmente, Abweichung: ${((1 - volumeData.polygonFactor) * 100).toFixed(3)}% ===`);
        });

        // Color scheme buttons
        const colorGrid = document.getElementById('colorGrid');
        colorSchemes.forEach((scheme, index) => {
            const button = document.createElement('div');
            button.className = 'color-button' + (index === 0 ? ' active' : '');

            // Set button background based on scheme type
            if (scheme.mode === 'faces') {
                // Show a grid of the 4 colors
                button.style.background = `linear-gradient(to right,
                    rgb(${scheme.colors[0][0]}, ${scheme.colors[0][1]}, ${scheme.colors[0][2]}) 0%,
                    rgb(${scheme.colors[0][0]}, ${scheme.colors[0][1]}, ${scheme.colors[0][2]}) 25%,
                    rgb(${scheme.colors[1][0]}, ${scheme.colors[1][1]}, ${scheme.colors[1][2]}) 25%,
                    rgb(${scheme.colors[1][0]}, ${scheme.colors[1][1]}, ${scheme.colors[1][2]}) 50%,
                    rgb(${scheme.colors[2][0]}, ${scheme.colors[2][1]}, ${scheme.colors[2][2]}) 50%,
                    rgb(${scheme.colors[2][0]}, ${scheme.colors[2][1]}, ${scheme.colors[2][2]}) 75%,
                    rgb(${scheme.colors[3][0]}, ${scheme.colors[3][1]}, ${scheme.colors[3][2]}) 75%)`;
            } else if (scheme.mode === 'uniform') {
                button.style.background = `rgb(${scheme.color[0]}, ${scheme.color[1]}, ${scheme.color[2]})`;
            } else {
                button.style.background = `linear-gradient(135deg,
                    rgb(${scheme.from[0]}, ${scheme.from[1]}, ${scheme.from[2]}),
                    rgb(${scheme.to[0]}, ${scheme.to[1]}, ${scheme.to[2]}))`;
            }

            button.title = scheme.name;
            button.addEventListener('click', () => {
                currentColorScheme = index;
                document.querySelectorAll('.color-button').forEach(b => b.classList.remove('active'));
                button.classList.add('active');

                const heightOffset = parseFloat(heightSlider.value);
                geometryData = generateAllGeometry(heightOffset, colorSchemes[currentColorScheme], currentSteps, currentSegments);
                device.queue.writeBuffer(vertexBuffer, 0, geometryData);
                numVertices = geometryData.length / 11;
            });
            colorGrid.appendChild(button);
        });

        // Camera fly button
        const cameraFlyBtn = document.getElementById('cameraFlyBtn');
        cameraFlyBtn.addEventListener('click', () => {
            cameraFlyActive = !cameraFlyActive;
            cameraFlyBtn.classList.toggle('active');
            if (cameraFlyActive) {
                hidePickInfo(); // Hide pick info when camera fly starts
            } else {
                flyTime = 0;
            }
        });

        // Reset button
        const resetBtn = document.getElementById('resetBtn');
        resetBtn.addEventListener('click', () => {
            // Stop camera fly if active
            if (cameraFlyActive) {
                cameraFlyActive = false;
                cameraFlyBtn.classList.remove('active');
                flyTime = 0;
            }

            // Reset camera
            camera.position = vec3.create(0, 700, 1200);
            camera.target = vec3.create(0, 100, 50);

            // Reset rotation
            rotation.x = 0.15;
            rotation.y = -20 * Math.PI / 180;

            // Reset sliders
            stepsSlider.value = 10;
            stepsValue.textContent = '10';
            currentSteps = 10;

            heightSlider.value = 0;
            heightValue.textContent = '0';

            segmentsSlider.value = 96;
            segmentsValue.textContent = '96';
            currentSegments = 96;

            brightnessSlider.value = 100;
            brightnessValue.textContent = '100%';
            currentBrightness = 1.0;

            // Reset color scheme
            currentColorScheme = 0;
            document.querySelectorAll('.color-button').forEach((b, i) => {
                b.classList.toggle('active', i === 0);
            });

            // Regenerate geometry
            geometryData = generateAllGeometry(0, colorSchemes[0], 10, 96);
            device.queue.writeBuffer(vertexBuffer, 0, geometryData);
            numVertices = geometryData.length / 11;

            // Update volume data
            volumeData = calculateVolumesAndAreas(10, 96);
        });

        // Render loop
        let lastTime = 0;
        function render(time) {
            time *= 0.001; // Convert to seconds
            const deltaTime = time - lastTime;
            lastTime = time;

            // Update camera from keyboard
            updateCameraFromKeys(deltaTime);

            // Update camera fly
            if (cameraFlyActive) {
                flyTime += deltaTime * flySpeed;
                camera.position = vec3.create(
                    Math.cos(flyTime) * flyRadius,
                    flyHeight + Math.sin(flyTime * 0.5) * 200,
                    Math.sin(flyTime) * flyRadius
                );
                camera.target = vec3.create(0, 0, 0);
            }

            // Resize canvas if needed (with HiDPI support)
            const currentDpr = window.devicePixelRatio || 1;
            const width = Math.floor(canvas.clientWidth * currentDpr);
            const height = Math.floor(canvas.clientHeight * currentDpr);
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                createDepthTexture(width, height);
                createPickingTextures(width, height);
            }

            // Calculate view-projection matrix
            const aspect = canvas.width / canvas.height;
            const projection = mat4.perspective(camera.fov, aspect, camera.near, camera.far);
            const view = mat4.lookAt(camera.position, camera.target, camera.up);
            
            // Apply rotation from mouse drag
            const rotationMatrix = mat4.identity();
            mat4.rotateX(rotationMatrix, rotation.x, rotationMatrix);
            mat4.rotateY(rotationMatrix, rotation.y, rotationMatrix);
            
            const viewProjection = mat4.multiply(projection, mat4.multiply(view, rotationMatrix));

            // Update uniforms with 3 light sources
            const uniformData = new Float32Array(32); // 128 bytes / 4 = 32 floats
            uniformData.set(viewProjection, 0);
            uniformData.set([...camera.position, currentBrightness], 16);
            // Light 1: from top-front-right
            uniformData.set([0.5, 1.0, 0.8, 0], 20);
            // Light 2: from left-front
            uniformData.set([-0.8, 0.3, 0.5, 0], 24);
            // Light 3: from below-back (fill light)
            uniformData.set([0.2, -0.5, -0.6, 0], 28);

            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            // Render
            const encoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();

            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: textureView,
                    clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                },
            });

            renderPass.setPipeline(pipeline);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(numVertices);
            renderPass.end();

            if (time < 1) { // Log once at start
                console.log('Rendering with', numVertices, 'vertices');
                console.log('ViewProjection matrix:', viewProjection);
            }

            device.queue.submit([encoder.finish()]);
            requestAnimationFrame(render);
        }

        // Initialize
        createDepthTexture(canvas.width, canvas.height);
        createPickingTextures(canvas.width, canvas.height);
        requestAnimationFrame(render);
    </script>
</body>
</html>